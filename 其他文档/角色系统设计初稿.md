# 1) 系统目标（What & Why）

* **核心目标**：用“**事件驱动 / 零时长**”方式，在时间拍点（flag）触发下，为每个角色决定“当下做什么、在哪里”。
* **叙事效果**：

  * 角色平时按 **routine（日常）** 行动；
  * **specials（特殊）** 条件满足时**覆盖** routine；
  * 在角色当前“**耐心窗口**”（由好感度等级决定）命中时，角色优先选择与主角**相伴/来访**；
  * **来访**受冷却机制控制，并可被不同好感等级个性化。
* **实现原则**：

  * **持久层（stat）** 存一切跨运行稳定配置；
  * **易失层（runtime）** 只存本次运行内的临时状态与日志；
  * 忽略旅行/持续时长，**触发即“瞬移+设目标”**，利于回滚与测试。

---

# 2) 运行所需外部数据（Reads）

* **`stat.user.所在地区`**：主角位置（相伴/来访参考）。
* **`runtime.clock`**：

  * `now.*`（年 / 月 / 日 / 周几 / 时段名与索引 `periodName/periodIdx` 等），
  * `flags.*`（`newPeriod/newDay/newWeek/newMonth/newSeason/newYear`，以及 `byPeriod.*` 等用于拍点触发）。
* **`runtime.festival`**：`current.name` 等（用作节日条件命中）。
* **`runtime.graph`**：地点邻接表（邻居/白名单/任意随机目标的抽取基础）。

---

# 3) 数据模型 · 持久层（`stat`）

> 一切跨运行稳定的设定、性格与日程，均在 `stat` 保存。

## 3.1 全局配置

* **`stat.config.affection.affectionStages: string[]`**

  * **统一格式（字符串化 JSON）**：每项包含

    * `threshold: number`（好感阈值，命中规则：好感度≥threshold 的最高项）、
    * `name: string`（等级名）、
    * `patienceUnit: "period" | "day" | "week" | "month"`（耐心窗口；仅在对应 flag 拍点才优先相伴/来访）、
    * `visit: { enabled:boolean, probBase:number, probK:number, coolUnit:"period"|"day"|"week"|"month" }`（该等级的来访偏好与冷却单位）。
  * **个性化覆盖**：角色可在 `stat.chars[角色].affectionStages` 自定义同结构数组，优先于全局。

## 3.2 角色字典（每个角色）

* **结构示例（精简）**：

```json
{
  "所在地区": "博丽神社",
  "居住地区": "博丽神社",
  "当前目标": "",
  "好感度": 85,

  "affectionStages": [ /* 可选；若提供则覆盖全局，结构同上 */ ],

  "routine": [ /* Entry[] — 与 specials 完全同构，见下 */ ],
  "specials": [ /* Entry[] — 命中即覆盖 routine，支持剩余次数 */ ]
}
```

### 3.3 行为条目（`Entry`）统一格式（`routine` 与 `specials` 通用）

* **`when`**（**同一对象内部为“与”，数组字段内部为“或”**）：

  * `byFlag: string[]` —— 直接写 `flags` 路径字面量（如 `"newMorning"`、`"byPeriod.newAfternoon"`）
  * `byNow: object` —— 与 `runtime.clock.now` 字段**逐项全等**（如 `{year, month, day, weekdayIndex, periodName, periodIdx}`）
  * `byMonthDay: {month, day}` —— 仅月日匹配
  * `byFestival: "ANY" | string | string[]` —— 当前节日名命中（或“任意节日”）
* **`action`**：

  * `do: string` —— 文案化的“做什么”
  * `to: string` —— 目标地点语法：

    * `HERO`（主角所在）、`FIXED:地点名`、`NEIGHBOR`（邻居随机）、`FROM:地点1|地点2|…`（白名单随机）、`ANY`（地图任意）
* **`priority: number`**（仅 specials 用于裁决，同时命中取最大）
* **`usesRemaining: number | null`**（本运行剩余可触发次数；`null` 表示无限）

---

# 4) 数据模型 · 易失层（`runtime`）

> 只存**本次运行**的临时计数、来访冷却与日志；程序结束即丢弃。

* **`runtime.clock` / `runtime.festival` / `runtime.graph`**：外部输入（见上）。
* **`runtime.charsState[角色]`**：

  * `visit: { cooling: boolean }`

    * 说明：成功来访后置 `cooling=true`；当拍点命中该角色当前等级的 `visit.coolUnit` 时自动复位为 `false`。
  * `usesLeft: Record<string, number>`（可选）

    * 说明：用于在**本运行**中追踪 `specials`/`routine` 中 `usesRemaining` 的**剩余**值；键可用“条目索引+类型”的轻量映射（实现自由）。
* **`runtime.logs: Array`**（结构自由）

  * 记录每次决策：时间、角色、触发来源（special/companion/visit/routine/idle）、前后地点/目标等，供回滚/审计/可视化。

**`runtime` 示例（局部）**：

```json
{
  "charsState": {
    "博丽灵梦": {
      "visit": { "cooling": false },
      "usesLeft": { "sp#0": 1 }
    }
  },
  "logs": [
    { "time": "2025-10-24T14:30:00+09:00", "char": "博丽灵梦", "trigger": "routine", "from": {"loc":"博丽神社","goal":""}, "to": {"loc":"人间之里","goal":"采购补给"} }
  ]
}
```

---

# 5) 角色决策 · 流程（新版）

> 决策流程被重构为按角色与主角的相对位置进行分组处理，以实现更清晰的逻辑分离。

1.  **预处理 (Preprocessing)**
    *   **解析好感度等级**：遍历所有角色，根据其好感度从 `affectionStages`（角色级优先，否则取全局）中解析出当前的 `affectionStage`（包含 `patienceUnit`, `visit` 等参数）。
    *   **重置来访冷却**：遍历所有角色，检查其 `runtime.charsState[角色].visit.cooling` 状态。如果为 `true` 且当前时间拍点命中了该角色当前等级的 `visit.coolUnit`，则将其冷却状态复位为 `false`。

2.  **角色分组 (Partitioning)**
    *   读取主角当前位置 `stat.user.所在地区`。
    *   根据角色当前位置 `stat.chars[角色].所在地区` 是否与主角相同，将所有角色分为两个列表：
        *   `coLocatedChars`：与主角在同一地区。
        *   `remoteChars`：与主角在不同地区。

3.  **异区角色决策：判定来访 (Process Remote Characters)**
    *   此步骤仅处理 `remoteChars` 列表。
    *   对列表中的每个角色，检查是否满足“来访”的所有条件：
        *   命中“耐心窗口” (`patienceUnit` 对应的 `flags` 为 `true`)。
        *   `visit.enabled` 为 `true`。
        *   `visit.cooling` 为 `false`。
        *   通过基于 `visit.probBase` 和 `visit.probK` 的概率检定。
    *   将所有决定来访的角色放入 `visitingChars` 列表，其行动被设定为：`{ to: 'HERO', do: '拜访主角' }`。

4.  **同区角色决策：判定相伴 (Process Co-located Characters)**
    *   此步骤仅处理 `coLocatedChars` 列表。
    *   对列表中的每个角色，检查是否满足“相伴”的条件：
        *   命中“耐心窗口” (`patienceUnit` 对应的 `flags` 为 `true`)。
    *   将所有决定继续相伴的角色放入 `stayingChars` 列表，其行动被设定为：`{ to: 'HERO', do: '与主角相伴' }`。

5.  **剩余角色决策：判定行动 (Process Remaining Characters)**
    *   从未被选入 `visitingChars` 或 `stayingChars` 的角色中，筛选出所有剩余角色，形成 `remainingChars` 列表。
    *   对 `remainingChars` 中的每个角色，按以下优先级顺序决定其行动：
        1.  **特殊行动 (`specials`)**：检查 `specials` 列表。如果找到满足 `when` 条件且 `usesRemaining` 未耗尽的条目，则采纳该行动（多条满足时取 `priority` 最高者）。
        2.  **日常行动 (`routine`)**：如果没有任何 `specials` 命中，则检查 `routine` 列表，采纳第一个满足 `when` 条件的条目。
        3.  **兜底 (Idle)**：如果以上均未命中，则角色保持“待机”，地点不变。
    *   将所有这些角色的决策结果存入 `actionTable`。

6.  **结果聚合与输出 (Aggregation & Output)**
    *   整合 `visitingChars`、`stayingChars` 和 `actionTable` 中的所有决策结果。
    *   根据这些决策，生成两个用于最终写入的对象：
        *   `statUpdates`：包含对 `stat.chars[角色].所在地区` 和 `stat.chars[角色].当前目标` 的所有修改。
        *   `runtimeUpdates`：包含对 `runtime.charsState`（如来访冷却、剩余次数）和 `runtime.logs` 的所有修改。
    *   将 `statUpdates` 和 `runtimeUpdates` 对象返回给上层调用者，由其负责原子化地应用更新。
